//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation::*;
use crate::Metal::*;

ns_options!(
    #[underlying(NSUInteger)]
    pub enum MTLBlitOption {
        MTLBlitOptionNone = 0,
        MTLBlitOptionDepthFromDepthStencil = 1 << 0,
        MTLBlitOptionStencilFromDepthStencil = 1 << 1,
        MTLBlitOptionRowLinearPVRTC = 1 << 2,
    }
);

extern_protocol!(
    pub unsafe trait MTLBlitCommandEncoder: MTLCommandEncoder {
        #[method(synchronizeResource:)]
        fn synchronizeResource(&self, resource: &ProtocolObject<dyn MTLResource>);

        #[method(synchronizeTexture:slice:level:)]
        unsafe fn synchronizeTexture_slice_level(
            &self,
            texture: &ProtocolObject<dyn MTLTexture>,
            slice: NSUInteger,
            level: NSUInteger,
        );

        #[method(copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:)]
        unsafe fn copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin(
            &self,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            source_slice: NSUInteger,
            source_level: NSUInteger,
            source_origin: MTLOrigin,
            source_size: MTLSize,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
            destination_slice: NSUInteger,
            destination_level: NSUInteger,
            destination_origin: MTLOrigin,
        );

        #[method(copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:)]
        unsafe fn copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin(
            &self,
            source_buffer: &ProtocolObject<dyn MTLBuffer>,
            source_offset: NSUInteger,
            source_bytes_per_row: NSUInteger,
            source_bytes_per_image: NSUInteger,
            source_size: MTLSize,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
            destination_slice: NSUInteger,
            destination_level: NSUInteger,
            destination_origin: MTLOrigin,
        );

        #[method(copyFromBuffer:sourceOffset:sourceBytesPerRow:sourceBytesPerImage:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:options:)]
        unsafe fn copyFromBuffer_sourceOffset_sourceBytesPerRow_sourceBytesPerImage_sourceSize_toTexture_destinationSlice_destinationLevel_destinationOrigin_options(
            &self,
            source_buffer: &ProtocolObject<dyn MTLBuffer>,
            source_offset: NSUInteger,
            source_bytes_per_row: NSUInteger,
            source_bytes_per_image: NSUInteger,
            source_size: MTLSize,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
            destination_slice: NSUInteger,
            destination_level: NSUInteger,
            destination_origin: MTLOrigin,
            options: MTLBlitOption,
        );

        #[method(copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:)]
        unsafe fn copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage(
            &self,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            source_slice: NSUInteger,
            source_level: NSUInteger,
            source_origin: MTLOrigin,
            source_size: MTLSize,
            destination_buffer: &ProtocolObject<dyn MTLBuffer>,
            destination_offset: NSUInteger,
            destination_bytes_per_row: NSUInteger,
            destination_bytes_per_image: NSUInteger,
        );

        #[method(copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toBuffer:destinationOffset:destinationBytesPerRow:destinationBytesPerImage:options:)]
        unsafe fn copyFromTexture_sourceSlice_sourceLevel_sourceOrigin_sourceSize_toBuffer_destinationOffset_destinationBytesPerRow_destinationBytesPerImage_options(
            &self,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            source_slice: NSUInteger,
            source_level: NSUInteger,
            source_origin: MTLOrigin,
            source_size: MTLSize,
            destination_buffer: &ProtocolObject<dyn MTLBuffer>,
            destination_offset: NSUInteger,
            destination_bytes_per_row: NSUInteger,
            destination_bytes_per_image: NSUInteger,
            options: MTLBlitOption,
        );

        #[method(generateMipmapsForTexture:)]
        fn generateMipmapsForTexture(&self, texture: &ProtocolObject<dyn MTLTexture>);

        #[method(fillBuffer:range:value:)]
        fn fillBuffer_range_value(
            &self,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            range: NSRange,
            value: u8,
        );

        #[method(copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:)]
        unsafe fn copyFromTexture_sourceSlice_sourceLevel_toTexture_destinationSlice_destinationLevel_sliceCount_levelCount(
            &self,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            source_slice: NSUInteger,
            source_level: NSUInteger,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
            destination_slice: NSUInteger,
            destination_level: NSUInteger,
            slice_count: NSUInteger,
            level_count: NSUInteger,
        );

        #[method(copyFromTexture:toTexture:)]
        unsafe fn copyFromTexture_toTexture(
            &self,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
        );

        #[method(copyFromBuffer:sourceOffset:toBuffer:destinationOffset:size:)]
        unsafe fn copyFromBuffer_sourceOffset_toBuffer_destinationOffset_size(
            &self,
            source_buffer: &ProtocolObject<dyn MTLBuffer>,
            source_offset: NSUInteger,
            destination_buffer: &ProtocolObject<dyn MTLBuffer>,
            destination_offset: NSUInteger,
            size: NSUInteger,
        );

        #[method(updateFence:)]
        fn updateFence(&self, fence: &ProtocolObject<dyn MTLFence>);

        #[method(waitForFence:)]
        fn waitForFence(&self, fence: &ProtocolObject<dyn MTLFence>);

        #[optional]
        #[method(getTextureAccessCounters:region:mipLevel:slice:resetCounters:countersBuffer:countersBufferOffset:)]
        unsafe fn getTextureAccessCounters_region_mipLevel_slice_resetCounters_countersBuffer_countersBufferOffset(
            &self,
            texture: &ProtocolObject<dyn MTLTexture>,
            region: MTLRegion,
            mip_level: NSUInteger,
            slice: NSUInteger,
            reset_counters: bool,
            counters_buffer: &ProtocolObject<dyn MTLBuffer>,
            counters_buffer_offset: NSUInteger,
        );

        #[optional]
        #[method(resetTextureAccessCounters:region:mipLevel:slice:)]
        unsafe fn resetTextureAccessCounters_region_mipLevel_slice(
            &self,
            texture: &ProtocolObject<dyn MTLTexture>,
            region: MTLRegion,
            mip_level: NSUInteger,
            slice: NSUInteger,
        );

        #[method(optimizeContentsForGPUAccess:)]
        fn optimizeContentsForGPUAccess(&self, texture: &ProtocolObject<dyn MTLTexture>);

        #[method(optimizeContentsForGPUAccess:slice:level:)]
        unsafe fn optimizeContentsForGPUAccess_slice_level(
            &self,
            texture: &ProtocolObject<dyn MTLTexture>,
            slice: NSUInteger,
            level: NSUInteger,
        );

        #[method(optimizeContentsForCPUAccess:)]
        unsafe fn optimizeContentsForCPUAccess(&self, texture: &ProtocolObject<dyn MTLTexture>);

        #[method(optimizeContentsForCPUAccess:slice:level:)]
        unsafe fn optimizeContentsForCPUAccess_slice_level(
            &self,
            texture: &ProtocolObject<dyn MTLTexture>,
            slice: NSUInteger,
            level: NSUInteger,
        );

        #[method(resetCommandsInBuffer:withRange:)]
        unsafe fn resetCommandsInBuffer_withRange(
            &self,
            buffer: &ProtocolObject<dyn MTLIndirectCommandBuffer>,
            range: NSRange,
        );

        #[method(copyIndirectCommandBuffer:sourceRange:destination:destinationIndex:)]
        unsafe fn copyIndirectCommandBuffer_sourceRange_destination_destinationIndex(
            &self,
            source: &ProtocolObject<dyn MTLIndirectCommandBuffer>,
            source_range: NSRange,
            destination: &ProtocolObject<dyn MTLIndirectCommandBuffer>,
            destination_index: NSUInteger,
        );

        #[method(optimizeIndirectCommandBuffer:withRange:)]
        unsafe fn optimizeIndirectCommandBuffer_withRange(
            &self,
            indirect_command_buffer: &ProtocolObject<dyn MTLIndirectCommandBuffer>,
            range: NSRange,
        );

        #[method(sampleCountersInBuffer:atSampleIndex:withBarrier:)]
        unsafe fn sampleCountersInBuffer_atSampleIndex_withBarrier(
            &self,
            sample_buffer: &ProtocolObject<dyn MTLCounterSampleBuffer>,
            sample_index: NSUInteger,
            barrier: bool,
        );

        #[method(resolveCounters:inRange:destinationBuffer:destinationOffset:)]
        unsafe fn resolveCounters_inRange_destinationBuffer_destinationOffset(
            &self,
            sample_buffer: &ProtocolObject<dyn MTLCounterSampleBuffer>,
            range: NSRange,
            destination_buffer: &ProtocolObject<dyn MTLBuffer>,
            destination_offset: NSUInteger,
        );
    }

    unsafe impl ProtocolType for dyn MTLBlitCommandEncoder {}
);
